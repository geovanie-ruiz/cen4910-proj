/*! @azure/msal-browser v3.5.0 2023-11-07 */
'use strict';
import { TimeUtils, AuthToken, AuthError, InteractionRequiredAuthError, ServerError, ClientAuthError, ClientAuthErrorCodes } from '@azure/msal-common';
import { isBridgeError } from '../BridgeError.mjs';
import { BridgeStatusCode } from '../BridgeStatusCode.mjs';

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
class NestedAppAuthAdapter {
    constructor(clientId, clientCapabilities, crypto, logger) {
        this.clientId = clientId;
        this.clientCapabilities = clientCapabilities;
        this.crypto = crypto;
        this.logger = logger;
    }
    toNaaSilentTokenRequest(request) {
        let extraParams;
        if (request.extraQueryParameters === undefined) {
            extraParams = new Map();
        }
        else {
            extraParams = new Map(Object.entries(request.extraQueryParameters));
        }
        /**
         * Need to get information about the client to populate request correctly
         * For example: client id, client capabilities
         */
        const tokenRequest = {
            userObjectId: request.account?.homeAccountId,
            clientId: this.clientId,
            authority: request.authority,
            scope: request.scopes.join(" "),
            correlationId: request.correlationId !== undefined
                ? request.correlationId
                : this.crypto.createNewGuid(),
            prompt: request.prompt !== undefined ? request.prompt : "",
            claims: request.claims !== undefined ? request.claims : "",
            authenticationScheme: request.authenticationScheme !== undefined
                ? request.authenticationScheme
                : "",
            clientCapabilities: this.clientCapabilities,
            extraParameters: extraParams,
        };
        return tokenRequest;
    }
    toNaaTokenRequest(request) {
        let extraParams;
        if (request.extraQueryParameters === undefined) {
            extraParams = new Map();
        }
        else {
            extraParams = new Map(Object.entries(request.extraQueryParameters));
        }
        const tokenRequest = {
            userObjectId: request.account?.homeAccountId,
            clientId: this.clientId,
            authority: request.authority,
            scope: request.scopes.join(" "),
            correlationId: request.correlationId !== undefined
                ? request.correlationId
                : "",
            prompt: request.prompt !== undefined ? request.prompt : "",
            nonce: request.nonce !== undefined ? request.nonce : "",
            claims: request.claims !== undefined ? request.claims : "",
            state: request.state !== undefined ? request.state : "",
            authenticationScheme: request.authenticationScheme !== undefined
                ? request.authenticationScheme
                : "",
            clientCapabilities: undefined,
            extraParameters: extraParams,
        };
        return tokenRequest;
    }
    fromNaaTokenResponse(request, response) {
        const expiresOn = new Date(TimeUtils.nowSeconds() + (response.expires_in || 0) * 1000);
        const account = this.fromNaaAccountInfo(response.account);
        const authenticationResult = {
            authority: response.account.environment,
            uniqueId: response.account.homeAccountId,
            tenantId: response.account.tenantId,
            scopes: response.scope.split(" "),
            account: this.fromNaaAccountInfo(response.account),
            idToken: response.id_token !== undefined ? response.id_token : "",
            idTokenClaims: account.idTokenClaims !== undefined
                ? account.idTokenClaims
                : {},
            accessToken: response.access_token,
            fromCache: true,
            expiresOn: expiresOn,
            tokenType: request.authenticationScheme !== undefined
                ? request.authenticationScheme
                : "Bearer",
            correlationId: request.correlationId,
            requestId: "",
            extExpiresOn: expiresOn,
            state: response.state,
        };
        return authenticationResult;
    }
    /*
     *  export type AccountInfo = {
     *     homeAccountId: string;
     *     environment: string;
     *     tenantId: string;
     *     username: string;
     *     localAccountId: string;
     *     name?: string;
     *     idToken?: string;
     *     idTokenClaims?: TokenClaims & {
     *         [key: string]:
     *             | string
     *             | number
     *             | string[]
     *             | object
     *             | undefined
     *             | unknown;
     *     };
     *     nativeAccountId?: string;
     *     authorityType?: string;
     * };
     */
    fromNaaAccountInfo(fromAccount) {
        let tokenClaims;
        if (fromAccount.idToken !== undefined) {
            tokenClaims = AuthToken.extractTokenClaims(fromAccount.idToken, this.crypto.base64Decode);
        }
        else {
            tokenClaims = undefined;
        }
        const account = {
            homeAccountId: fromAccount.homeAccountId,
            environment: fromAccount.environment,
            tenantId: fromAccount.tenantId,
            username: fromAccount.username,
            localAccountId: fromAccount.localAccountId,
            name: fromAccount.name,
            idToken: fromAccount.idToken,
            idTokenClaims: tokenClaims,
        };
        return account;
    }
    /**
     *
     * @param error BridgeError
     * @returns AuthError, ClientAuthError, ClientConfigurationError, ServerError, InteractionRequiredError
     */
    fromBridgeError(error) {
        if (isBridgeError(error)) {
            switch (error.status) {
                case BridgeStatusCode.USER_CANCEL:
                    return new ClientAuthError(ClientAuthErrorCodes.userCanceled);
                case BridgeStatusCode.NO_NETWORK:
                    return new ClientAuthError(ClientAuthErrorCodes.noNetworkConnectivity);
                case BridgeStatusCode.ACCOUNT_UNAVAILABLE:
                    return new ClientAuthError(ClientAuthErrorCodes.noAccountFound);
                case BridgeStatusCode.DISABLED:
                    return new ClientAuthError(ClientAuthErrorCodes.nestedAppAuthBridgeDisabled);
                case BridgeStatusCode.NESTED_APP_AUTH_UNAVAILABLE:
                    return new ClientAuthError(error.code, error.description);
                case BridgeStatusCode.TRANSIENT_ERROR:
                case BridgeStatusCode.PERSISTENT_ERROR:
                    return new ServerError(error.code, error.description);
                case BridgeStatusCode.USER_INTERACTION_REQUIRED:
                    return new InteractionRequiredAuthError(error.code, error.description);
                default:
                    return new AuthError(error.code, error.description);
            }
        }
        else {
            return new AuthError("unknown_error", "An unknown error occurred");
        }
    }
}

export { NestedAppAuthAdapter };
//# sourceMappingURL=NestedAppAuthAdapter.mjs.map
